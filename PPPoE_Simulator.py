from os import path
from urllib.parse import urlparse

from scapy.all import *
from scapy.layers.http import *
from scapy.layers.inet import *
from scapy.layers.ppp import *

load_layer("http")

# In most cases you just have to change this:
interface = "enp0s3"
# --------------------------------
max_chunk_size = 1320
pkt_per_ack = 5  # Send N packet at once. Results in a few Dup Acks at end of transmission due to lag
net_GW = "10.15.0.8"
net_IP = "10.16.0.9"
net_DNS1 = "8.8.8.8"
net_DNS2 = "8.8.4.4"
ac_name = "PPPoE-Simulator"
magic_number = 0xDEADBEEF
service_name = ""
host_uniq = session_id = mac_router = mac_server = eth_discovery = eth_session = file = nextseq = eth2ip = None
ident = 0
transmitting = False

End_Of_List = 0x0000
Service_Name = 0x0101
AC_Name = 0x0102
Host_Uniq = 0x0103
AC_Cookie = 0x0104
Vendor_Specific = 0x0105
Relay_Session_Id = 0x0110
Service_Name_Error = 0x0201
AC_System_Error = 0x0202
Generic_Error = 0x0203

PADI = 0x09
PADO = 0x07
PADR = 0x19
PADS = 0x65
PADT = 0xa7

LCP = 0xc021
PAP = 0xc023
CHAP = 0xc223
IPCP = 0x8021
IPV6CP = 0x8057
PPPoE_Discovery = 0x8863
PPPoE_Session = 0x8864

Configure_Request = 1
Configure_Ack = 2
Authenticate_Ack = 2
Configure_Nak = 3
Configure_Reject = 4
Terminate_Request = 5
Terminate_Ack = 6
Code_Reject = 7
Protocol_Reject = 8
Echo_Request = 9
Echo_Reply = 10
Discard_Request = 11

SYN = 0x002
ACK = 0x010
FIN_ACK = 0x011
PSH_ACK = 0x018


def packet_callback(pkt):
    global host_uniq, session_id, ident, mac_router, mac_server, eth_discovery, eth_session, transmitting

    eth_session = Ether(src=mac_server, dst=mac_router, type=PPPoE_Session)

    if pkt.haslayer(PPPoED):
        transmitting = False  # Reset transmitting in case of PPPoE reconnect
        mac_router = pkt[Ether].src
        eth_discovery = Ether(src=mac_server, dst=mac_router, type=PPPoE_Discovery)
        if pkt[PPPoED].code == PADI:
            session_id = pkt[PPPoED].fields['sessionid']
            ac_cookie = os.urandom(20)
            for tag in pkt[PPPoED][PPPoED_Tags].tag_list:
                if tag.tag_type == Host_Uniq:
                    host_uniq = tag.tag_value
            print("Client->Server   |   Discovery Initiation")
            print("Server->Client   |   Discovery Offer")
            sendp(eth_discovery /
                  PPPoED(code=PADO, sessionid=0) /
                  PPPoETag(tag_type=Service_Name, tag_value=service_name) /
                  PPPoETag(tag_type=AC_Name, tag_value=ac_name) /
                  PPPoETag(tag_type=AC_Cookie, tag_value=ac_cookie) /
                  PPPoETag(tag_type=Host_Uniq, tag_value=host_uniq))
        elif pkt[PPPoED].code == PADR:

            print("Client->Server   |   Discovery Request")
            print("Server->Client   |   Discovery Session-confirmation")
            session_id = os.urandom(2)[0]
            sendp(eth_discovery /
                  PPPoED(code=PADS, sessionid=session_id) /
                  PPPoETag(tag_type=Service_Name, tag_value=service_name) /
                  PPPoETag(tag_type=Host_Uniq, tag_value=host_uniq))
            print("Server->Client   |   Configuration Request (PAP)")
            sendp(eth_session /
                  PPPoE(sessionid=session_id) /
                  PPP(proto=LCP) /
                  PPP_LCP(code=Configure_Request, id=ident + 1, data=(Raw(PPP_LCP_MRU_Option(max_recv_unit=1492)) /
                                                                      Raw(PPP_LCP_Auth_Protocol_Option(
                                                                          auth_protocol=PAP)) /
                                                                      Raw(PPP_LCP_Magic_Number_Option(
                                                                          magic_number=magic_number)))))
    elif pkt.haslayer(PPPoE) and pkt.haslayer(PPP):
        mac_router = pkt[Ether].src
        if pkt[PPPoE].sessionid != 0:
            session_id = pkt[PPPoE].sessionid
        if pkt.haslayer(PPP_LCP_Configure):
            ppp_lcp = pkt[PPP_LCP_Configure]
            if pkt[PPP_LCP_Configure].code == Configure_Request:
                ident = pkt[PPP_LCP_Configure].id
                print("Client->Server   |   Configuration Request (MRU)")
                print("Server->Client   |   Configuration Ack (MRU)")
                sendp(eth_session /
                      PPPoE(sessionid=session_id) /
                      PPP(proto=LCP) /
                      PPP_LCP(code=Configure_Ack, id=ident, data=(Raw(PPP_LCP_MRU_Option(max_recv_unit=1480)) /
                                                                  Raw(ppp_lcp[PPP_LCP_Magic_Number_Option]))))
            elif pkt[PPP_LCP_Configure].code == Configure_Ack:
                print("Client->Server   |   Configuration Ack")
                print("Server->Client   |   Echo Request")
                sendp(eth_session /
                      PPPoE(sessionid=session_id) /
                      PPP(proto=LCP) /
                      PPP_LCP_Echo(code=Echo_Request, id=ident + 1, magic_number=magic_number))
        elif pkt.haslayer(PPP_LCP_Echo):
            if pkt[PPP_LCP_Echo].code == Echo_Request:
                ident = pkt[PPP_LCP_Echo].id
                print("Client->Server   |   Echo Request")
                print("Server->Client   |   Echo Reply")
                sendp(eth_session /
                      PPPoE(sessionid=session_id) /
                      PPP(proto=LCP) /
                      PPP_LCP_Echo(code=Echo_Reply, id=ident, magic_number=magic_number))
        elif pkt.haslayer(PPP_PAP_Request):
            ident = pkt[PPP_PAP_Request].id
            print("Client->Server   |   Authentication Request")
            print("Server->Client   |   Authenticate Ack")
            sendp(eth_session /
                  PPPoE(sessionid=session_id) /
                  PPP(proto=PAP) /
                  PPP_PAP_Response(code=Authenticate_Ack, id=ident, message="Login ok"))
            print("Server->Client   |   Configuration Request (IP)")
            sendp(eth_session /
                  PPPoE(sessionid=session_id) /
                  PPP(proto=IPCP) /
                  PPP_IPCP(code=Configure_Request, id=ident + 1, options=PPP_IPCP_Option_IPAddress(data=net_GW)))
        elif pkt.haslayer(PPP_IPCP):
            ident = pkt[PPP_IPCP].id
            if pkt[PPP_IPCP].options[0].data == "0.0.0.0":
                options = [PPP_IPCP_Option_IPAddress(data=net_IP),
                           PPP_IPCP_Option_DNS1(data=net_DNS1),
                           PPP_IPCP_Option_DNS2(data=net_DNS2)]
                print("Client->Server   |   Configuration Request (invalid)")
                print("Server->Client   |   Configuration Nak")
                sendp(eth_session /
                      PPPoE(sessionid=session_id) /
                      PPP(proto=IPCP) /
                      PPP_IPCP(code=Configure_Nak, id=ident, options=options))
            else:
                print("Client->Server   |   Configuration Request (valid)")
                print("Server->Client   |   Configuration Ack")
                sendp(eth_session /
                      PPPoE(sessionid=session_id) /
                      PPP(proto=IPCP) /
                      PPP_IPCP(code=Configure_Ack, id=ident, options=pkt[PPP_IPCP].options))
        if pkt[PPP].proto == IPV6CP:
            print("Client->Server   |   Configuration Request IPV6CP")
            print("Server->Client   |   Protocol Reject IPV6CP")
            sendp(eth_session /
                  PPPoE(sessionid=session_id) /
                  PPP(proto=LCP) /
                  PPP_LCP_Protocol_Reject(code=Protocol_Reject, id=ident + 1, rejected_protocol=IPV6CP,
                                          rejected_information=pkt[PPP].payload))
        if pkt.haslayer(TCP):
            if pkt[TCP].dport == 80:
                httpHandle(pkt)


def httpHandle(pkt):
    global transmitting, file, nextseq, eth2ip
    if not eth2ip:  # Define Ethernet, PPPoE, PPP and IP layer once since they don't change
        eth2ip = (eth_session /
                  PPPoE(sessionid=session_id) /
                  PPP() / IP(dst=pkt[IP].src, src=pkt[IP].dst))

    if pkt.haslayer(HTTPRequest) and not transmitting:
        lenrequest = len(pkt[HTTPRequest])
        file_name = urlparse(str(pkt[HTTPRequest].Path, "utf-8")).path[1:]

        print("Request          |   Get /" + file_name)
        print("Response         |   ACK")
        sendp(eth2ip /
              TCP(dport=pkt[TCP].sport, sport=pkt[TCP].dport, seq=pkt[TCP].ack,
                  ack=pkt[TCP].seq + lenrequest,
                  flags="A"))

        if path.isfile(file_name):
            file = open(file_name, "rb")
            file_data = file.read(max_chunk_size)
            chunk_len = calcChunkLen(file_data)
            data = chunk_len + b"\x0d\x0a" + file_data + b"\x0d\x0a"

            p = (eth2ip /
                 TCP(dport=pkt[TCP].sport, sport=pkt[TCP].dport, seq=pkt[TCP].ack,
                     ack=pkt[TCP].seq + lenrequest,
                     flags=PSH_ACK) /
                 HTTPResponse(Transfer_Encoding="chunked", Content_Length=str(path.getsize(file_name))) /
                 data)
            nextseq = p[TCP].seq + len(p[TCP].payload)
            transmitting = True
            print("Response         |   200OK First Chunk")
            sendp(p)

    elif pkt[TCP].flags == ACK and transmitting:
        # print("Request         |   Chunk ACK") # Spams console when transmitting large files
        for i in range(pkt_per_ack):  # Don't wait for next ack. Send N packet at once.
            file_data = file.read(max_chunk_size)
            if not file_data:
                transmitting = False
                file.close()
                print("Response         |   Zero-Length Chunk")
                sendp(eth2ip /
                      TCP(dport=pkt[TCP].sport, sport=pkt[TCP].dport,
                          seq=nextseq,
                          ack=pkt[TCP].seq,
                          flags=PSH_ACK) /
                      b"\x30\x0d\x0a\x0d\x0a")
                print("Response         |   FIN,ACK")
                sendp(eth2ip /
                      TCP(dport=pkt[TCP].sport, sport=pkt[TCP].dport, seq=nextseq + 5, ack=pkt[TCP].seq, flags="AF"))
                break
            else:
                chunk_len = calcChunkLen(file_data)
                data = chunk_len + b"\x0d\x0a" + file_data + b"\x0d\x0a"

                p = (eth2ip /
                     TCP(dport=pkt[TCP].sport, sport=pkt[TCP].dport, seq=nextseq,
                         ack=pkt[TCP].seq,
                         flags=PSH_ACK) /
                     data)
                nextseq = p[TCP].seq + len(p[TCP].payload)
                # print("Response         |   Chunck") # Spams console when transmitting large files
                sendp(p)

    elif pkt[TCP].flags == SYN and not transmitting:
        print("Request          |   SYN")
        print("Response         |   SYN,ACK")
        sendp(eth2ip /
              TCP(dport=pkt[TCP].sport, sport=pkt[TCP].dport, ack=pkt[TCP].seq + 1, flags="SA"))
    elif pkt[TCP].flags == FIN_ACK:
        print("Request          |   FIN,ACK")
        print("Response         |   ACK")
        sendp(eth2ip /
              TCP(dport=pkt[TCP].sport, sport=pkt[TCP].dport, seq=pkt[TCP].ack + 1, ack=pkt[TCP].seq + 1,
                  flags="A"))


def calcChunkLen(data):
    return hex(len(data)).lstrip("0x").encode("ascii")


def terminateConnection():
    print("Server->Client   |   Terminate Connection")
    sendp(eth_session /
          PPPoE(sessionid=session_id) /
          PPP(proto=LCP) /
          PPP_LCP_Terminate())


def isNotOutgoing(pkt):
    if pkt.haslayer(Ether):
        return pkt[Ether].src != mac_server
    return False


if __name__ == '__main__':
    conf.verb = 0  # Suppress Scapy output
    conf.iface = interface  # Set default interface
    conf.recv_poll_rate = 0.0000001 # Reduces sleep, ping went down from 110ms to 30ms
    mac_server = get_if_hwaddr(interface)
    print("Waiting for packets")
    sniff(prn=packet_callback, filter="pppoed or pppoes", lfilter=isNotOutgoing)
